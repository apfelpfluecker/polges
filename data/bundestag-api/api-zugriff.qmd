# Zugriff auf die Bundestags-API

Einmal testen.

```{r}
# Simple Anleitung: https://www.r-bloggers.com/2020/02/r-api-tutorial-getting-started-with-apis-in-r/
# Laden von benötigten Paketen
library(httr)
library(jsonlite)
library(dplyr)

# GET-Request starten mit GET-Funktion und speichern in res
res = GET("http://api.open-notify.org/astros.json")

# Output ist der Link, Datum der Abfrage, Status (200 = alles gut), Kontent-Typ und Größe
res

# Der Inhalt ist raw Unicode, wir brauchen aber JSON, weil das das Standardformat für API-Daten ist. Deshalb packen wir das raw in einen character-Vektor
rawToChar(res$content)

# den character-Vektor können wir in eine JSON-strukturierte Liste packen
# fromJSON benötigt einen character Vektor mit JSON-Struktur
data = fromJSON(rawToChar(res$content))

```

Jetzt für den Bundestag testen

```{r}
# API-Key gültig bis Mai 2025
# https://dip.bundestag.de/%C3%BCber-dip/hilfe/api
api_key <- "I9FKdCn.hbfefNWCY336dL6x62vfwNKpoN2RZ1gp21"
url <- "https://search.dip.bundestag.de/api/v1/vorgang"

res <- GET(url = url, query = list(apikey = api_key))


```

und jetzt für Anträge testen

```{r}
# Key gültig bis 05/2025
api_key <- "I9FKdCn.hbfefNWCY336dL6x62vfwNKpoN2RZ1gp21"
url <- "https://search.dip.bundestag.de/api/v1/drucksache-text"

res <- GET(url, query = list (
  apikey = api_key,
  f.datum.start = "2017-09-24",
  f.datum.end = "2024-06-119",
  f.drucksachetyp = "Antrag"
))

data <- fromJSON(rawToChar(res$content))
ds <- as.data.frame(data)
ds
```

## Skript zur automatisierten Abfrage

```{r}
# Simple Anleitung: https://www.r-bloggers.com/2020/02/r-api-tutorial-getting-started-with-apis-in-r/
# Laden von benötigten Paketen
library(httr)
library(jsonlite)
library(dplyr)

# API-Key (gültig bis 05/25)
api_key <- "I9FKdCn.hbfefNWCY336dL6x62vfwNKpoN2RZ1gp21"
# URL
url <- "https://search.dip.bundestag.de/api/v1/drucksache-text"
# Config ändern, damit Verbindung funktioniert
#set_config(use_proxy(url="10.3.100.207",port=8080))

# Funktion für API-Anfrage
request <- function(key, url, start, end, type, cursor){
  res <- GET(url, query = list (
    apikey = key,
    f.datum.start = start,
    f.datum.end = end,
    f.drucksachetyp = type,
    cursor = cursor),
    config = list(ssl_version = 3)
  )
  data <- fromJSON(rawToChar(res$content))
  return(data)
}

# erstes Ziehen nicht über die Funktion
res <- GET(url, query = list (
  apikey = api_key,
  f.datum.start = "2017-09-24",
  f.datum.end = "2024-06-19",
  f.drucksachetyp = "Antrag"),
  config = list(ssl_version = 3)
)
# entpacktes Ergebnis in data speichern
data <- fromJSON(rawToChar(res$content))
# Gesamtdatensatz erstellen, wo alle relevanten Ergebnisse gespeichert werden
ds_gesamt <- as.data.frame(data$documents)

# Cursor der aktuellen Anfrage abspeichern
cursor_alt <- data$cursor
x <- TRUE

# Schleife, die solange Anfragen an die API stellt, bis der alte Cursor mit dem neuen Cursor gleich ist
# Achtung! Dauert lange, da zwischendurch 2 Sekunden Pause gemacht wird, damit das Limit der API nicht erreicht wird
while(x == TRUE){
  data_neu <- request(api_key, url, start = "2017-09-24", end = "2024-06-18", type = "Antrag", cursor = cursor_alt)
  if (cursor_alt != data_neu$cursor) {
    # Füge neuen Datensatz zum Gesamtdatensatz hinzu (rbind hat Probleme mit doppelten Spaltennamen)
    ds_gesamt <- bind_rows(ds_gesamt, as.data.frame(data_neu$documents))
    #Cursor aktualisieren
    cursor_alt <- data_neu$cursor
    Sys.sleep(2)
  }
  else {
    x <- FALSE
  }
}

# entstehenden Datensatz speichern
saveRDS(ds_gesamt, file = "../btantraege.Rds")

```
